---
title: "Why REST?: An Introduction to Angular 2"
date: 2016-12-15 21:31:13 -0500
layout: blog
tags: [angular, restful, angstrom]
---

Over the past few weeks, as I've been putting the pieces together for the new &aring;ngstromCTF frontend, I've learned a lot about how [Angular 2](https://angular.io/) works and what it's useful for. Having never used a real JavaScript framework before in my life, Angular 2 has really blown me away with the attention to detail and form that its designers had. Unlike other framework that I've used for GUI applications in the past, like Swing or Tkinter, Angular 2 *just makes sense*. It's really facilitated the development of the relatively complex application I'm writing, and I could see how it could easily scale to much bigger projects. I've been using Angular in TypeScript, just because it's the most supported version, but JavaScript or Dart would work just fine too.

### Dependency Injection

Angular's designers use the brilliant paradigm of [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection), which I'd never heard of before, all throughout the framework. The basic idea is that, instead of your code going and loading some class from a library to do stuff, an object gets passed into your code's constructor at runtime. I know you're asking, *What? How does this make any sense?*. But it actually makes app development a whole lot easier.

Angular is organized around the idea of **components**, which are simple, reusable pieces of code. Every page on your site is its own component, but components can also represent small pieces of pages. When you start writing Angular code, you quickly find that there's code that needs to be shared between components. Not just code, in fact, but application state: if you log in on one component, all the other components need to be able to know that somehow. Angular's solution is to create classes called **services** that do things like provide utility functions and track application state and then magically **inject** each service into the classes that need it. In &aring;ngstrom, for example, the `StatusService` service tracks whether the user is logged in, has a team, and if the contest has started or ended. Every component that needs access to the status service simply asks for it and then receives it as an argument to its constructor.

### REST

When I started rewriting the platform earlier this year, everyone else on the project kept asking me why I was doing it, seeing as we had a perfectly fine Django platform that worked last year. I knew I wanted to redesign how the site looked and have a new theme, and when I started trying to do that, I quickly ran up against a problem: even though I'd tried my best, the Django views and Django templates were hopelessly intertwined. Django views were selecting how to render error messages and what colors to use for problems. Everything seemed wrong, and when I tried making some minor changes, everything broke.

Here came REST to the rescue! REST, which stands for REpresentational State Transfer, is a type of web service. When I rewrote my application to be RESTful, I split it up into two pieces: the client-side frontend, and the server-side backend. The client-side frontend is entirely static HTML, JavaScript, and CSS, while the backend is a complex network of tools and services. The frontend takes care of how the site looks and feels, while the backend actually does the important work: tracks users and teams and flags. This logical division is realized by actually splitting up the two (I actually put them in different repositories!). I adapted the Django code I already had to be a RESTful API using [Django REST framework](http://www.django-rest-framework.org/) and then used Angular 2 to develop an independent frontend. This dichotomy is faster, more stable, and more secure than having an integrated application.

How the app works is as follows: most of the time the user is on the site, they don't even need to access the backend (for example, when they're looking at the home and about pages). When API access to the backend is necessary, the component in question gets injected with a service that provides API access. The component calls a function on the injected API service that makes an HTTP request through Angular's HTTP API across the Internet to the backend, encoding the relevant information in JSON. Then, when the backend finishes, it returns JSON data back as the response, and the Angular app interprets it how it wants, updating the display when necessary.
